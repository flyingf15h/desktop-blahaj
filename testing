from ctypes import windll
import random
import tkinter as tk
import time
import math
from PIL import Image, ImageTk

print("blohai :3")

# Initial position of the pet within the window
pet_x = random.randint(200, 1300)
pet_y = random.randint(100, 500)
state = 1
gifPath = 'C:\\Users\\bramb\\OneDrive\\Documents\\VSCode\\desktop pet blahaj\\gifs\\'
lastSleep = 0 
sleepLength = 0  
screenWidth, screenHeight = 1500, 1080  
lastDirection = "right"  # Direction blahaj was facing
swimTime = 0 
animationLocked = False
idlePhase = 0

# Window config (fixed to screen size minus taskbar area)
window = tk.Tk()
window.config(highlightbackground='black')
window.wm_attributes('-transparentcolor', 'black')
window.title("Desktop Pet")

# Set window size to screen dimensions, minus a bit for the taskbar
window.geometry(f"{screenWidth}x{screenHeight - 40}")
window.overrideredirect(True)  # No toolbar
window.attributes('-topmost', True)  # Keep on top
window.config(bg='black')  # Background color set to a color that can be made transparent
window.wm_attributes('-transparentcolor', 'black')  # Set black as the transparent color

# Control backslash to close program
def close_program(event=None):
    print("Closing program")
    window.destroy()
window.bind("<Control-q>", close_program)

# Label to display the pet's animations with a transparent background
label = tk.Label(window, bd=0, bg='black')
label.place(x=pet_x, y=pet_y)  # Initial position within the window

# Load and manage gifs
def loadGif(file_path):
    imagePil = Image.open(file_path)
    frames = []
    try:
        while True:
            frame = ImageTk.PhotoImage(imagePil.copy().convert("RGBA"))
            frames.append(frame)
            imagePil.seek(len(frames))  # Move to the next frame
    except EOFError:
        pass
    return frames

# Load animations as lists of frames
idles = {
    "idle_right": loadGif(gifPath + 'idle.gif'),
    "idle_left": loadGif(gifPath + 'idleLeft.gif'),
    "idle_plant": loadGif(gifPath + 'idle_plant.gif'),
    "idle_music": loadGif(gifPath + 'idle_music.gif'),
    "idle_candy": loadGif(gifPath + 'idle_candy.gif'),
    "idle_fish": loadGif(gifPath + 'idle_fish.gif')
}

to_sleep = loadGif(gifPath + 'to_sleep.gif')
sleeping = loadGif(gifPath + 'sleeping.gif')
to_awake = loadGif(gifPath + 'to_awake.gif')
swim_right = loadGif(gifPath + 'swim_right.gif')
swim_left = loadGif(gifPath + 'swim_left.gif')

currIdle = idles["idle_right"]
frameIndex = 0  # Frame counter
frames = []

# Choose idle animation
def setIdleAnim():
    global currIdle, lastDirection
    num = random.randint(1, 16)
    if num == 11:
        lastDirection = "right"
        currIdle = idles["idle_plant"]
    elif num == 12:
        lastDirection = "right"
        currIdle = idles["idle_music"]
    elif num == 13:
        lastDirection = "right"
        currIdle = idles["idle_candy"]
    elif num == 14:
        lastDirection = "right"
        currIdle = idles["idle_fish"]
    else:
        if lastDirection == "right":
            currIdle = idles["idle_right"]
        elif lastDirection == "left":
            currIdle = idles["idle_left"]
    return currIdle 

# Updates the animation and position of the pet
def behavior():
    global state, pet_x, pet_y, lastSleep, sleepLength, currIdle, lastDirection, frameIndex, frames, swimTime, animationLocked, idlePhase

    print(f"Pet coordinates: x = {pet_x}, y = {pet_y}")

    if not animationLocked:
        # Update frames based on current state
        if state == 0:  # Idle
            frames = setIdleAnim()
        elif state == 1:  # Idle to sleep
            frames = to_sleep
            lastSleep = time.time()
            sleepLength = random.randint(20, 100) * 1000
            window.after(sleepLength, wakeUp)
            state = 2
        elif state == 2:  # Sleeping
            frames = sleeping
        elif state == 3:  # Waking up
            frames = to_awake
        elif state == 4:  # Swimming left
            lastDirection = "left"
            frames = swim_left
            if swimTime == 0:
                swimTime = time.time()  # Start swimming timer
        elif state == 5:  # Swimming right
            lastDirection = "right"
            frames = swim_right
            if swimTime == 0:
                swimTime = time.time()  # Start swimming timer
        animationLocked = True

    # Dimensions for pet to prevent going off-screen
    pet_width, pet_height = 210, 158  # Adjust as needed
    screen_width, screen_height = screenWidth, screenHeight - 40  # Adjusted for taskbar

    # Update position based on state and constrain to screen bounds
    if state == 0:  # Idle bobbing movement
        pet_y += math.sin(idlePhase) * 3
        idlePhase += 0.1
    elif state == 4:  # Swimming left
        pet_x = max(pet_x - 10, 0)  # Move left with boundary check
        pet_y = min(max(pet_y + random.choice([-6, 6]), 0), screen_height - pet_height)
        # Stop swimming after 2 seconds
        if time.time() - swimTime > 2:
            swimTime = 0  # Reset timer
            state = 0  # Return to idle state
    elif state == 5:  # Swimming right
        pet_x = min(pet_x + 10, screen_width - pet_width)  # Move right with boundary check
        pet_y = min(max(pet_y + random.choice([-6, 6]), 0), screen_height - pet_height)
        # Stop swimming after 2 seconds
        if time.time() - swimTime > 2:
            swimTime = 0  # Reset timer
            state = 0  # Return to idle state

    # Enforce final boundary constraints
    pet_x = max(0, min(pet_x, screen_width - pet_width))
    pet_y = max(0, min(pet_y, screen_height - pet_height))

    # Update label position to simulate pet movement within the fixed window
    label.place(x=pet_x, y=int(pet_y))

    # Play frames
    frameIndex = (frameIndex + 1) % len(frames)
    label.configure(image=frames[frameIndex])
    label.image = frames[frameIndex]

    # Unlock after last frame
    if frameIndex == len(frames) - 1:
        animationLocked = False

    window.after(80, behavior)



# Behavior transitions
def event():
    global state, lastSleep, currIdle, swimTime, lastDirection, animationLocked
    eventNum = random.randint(1, 20)

    # To sleep
    if eventNum in [12, 13] and (time.time() - lastSleep > 10) and state == 0: 
        swimTime = 0
        state = 1

    # Swim right
    elif (eventNum in [11, 14, 15, 16] and pet_x <= (screenWidth - 210)) or pet_x >= 150:
        if swimTime == 0:
            swimTime = time.time()
        lastDirection = "right" 
        state = 5

    # Swim left
    elif (eventNum in [10, 17, 18, 19] and pet_x >= 200) or pet_x >= (screenWidth - 210): 
        if swimTime == 0:
            swimTime = time.time()
        lastDirection = "left"
        state = 4

    # Idle animations
    if eventNum <= 9:
        swimTime = 0
        setIdleAnim()
        state = 0
    
    # Wake up
    elif eventNum == 20 and state == 2:
        swimTime = 0
        state = 3
    
    window.after(500, event)

# Return to idle after sleeping
def wakeUp():
    global state
    state = 0

# Start the main animation and event loops
window.after(80, behavior)
window.after(500, event)
window.mainloop()
